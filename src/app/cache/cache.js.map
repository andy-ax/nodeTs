{"version":3,"file":"cache.js","sourceRoot":"","sources":["cache.ts"],"names":[],"mappings":"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","sourcesContent":["import {File} from '..';\r\nconst crypto = require(\"crypto\");\r\n\r\n/**\r\n * if-modified-since/Last-Modified 请求头/响应头\r\n *      传输文件时会将文件最后更新时间Last-Modified发送给前端\r\n *      下次前端请求文件时会将之前的最后更新时间作为if-modified-since传给后端做判断文件是否过期\r\n * if-none-match/ETag 同上，但if-modified-since/Last-Modified只能精确到秒\r\n *      而if-none-match/ETag使用特征串 但是Etag在分布式环境里，会给服务器造成压力\r\n * Expires: 设置一个时间戳，与客户端时间比对，如果在该时间戳内则不用更新文件 缺点在于依赖于客户端时间，并不准确\r\n * Cache-Control 设置超时时间，无需与客户端比对，需要HTTP1.1以上版本支持\r\n *\r\n * Cache-Control 与 Last-Modified的区别 Cache-Control设置超时时间，超过该时间，浏览器会自动获取新文件 Last-Modified 会一直比对文件最后更新时间，如果不一致则更新\r\n */\r\n\r\nexport class Cache {\r\n    private static EXPIRES = 20 * 60 * 1000;\r\n\r\n    /**\r\n     * 设定超时时间\r\n     * @param expires\r\n     */\r\n    static configExpires(expires: number) {\r\n        this.EXPIRES = expires;\r\n    }\r\n\r\n    /**\r\n     * 客户端的文件请求，判断客户端的文件时间戳是否与服务器端的文件时间戳一样\r\n     * @param path\r\n     * @param req\r\n     * @param res\r\n     */\r\n    static checkModified(path: string, req: Request, res: Response): Promise<any> {\r\n        return new Promise<any>((resolve, reject) => {\r\n            let lastModified: any;\r\n            File.readFileMsg(path).then((stat) => {\r\n                lastModified = stat.mtime.toUTCString();\r\n                // @ts-ignore\r\n                if (lastModified === req.headers['if-modified-since']) {\r\n                    resolve(null);\r\n                } else {\r\n                    return File.readFile(path);\r\n                }\r\n            }).then(str => {\r\n                res.setHeader(\"Last-Modified\", lastModified);\r\n                resolve(str);\r\n            }).catch(err => {\r\n                reject(err);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 根据etag判断文件是否已过期\r\n     * @param path\r\n     * @param req\r\n     * @param res\r\n     */\r\n    static checkETag(path: string, req: Request, res: Response): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            // @ts-ignore\r\n            File.readFile(path).then((str: string) => {\r\n                const hash = Cache.getHash(str);\r\n                // @ts-ignore\r\n                const noneMatch = req.headers['if-none-match'];\r\n                if (hash === noneMatch) {\r\n                    resolve()\r\n                } else {\r\n                    res.setHeader(\"ETag\", hash);\r\n                    reject(str);\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 设置超时时间\r\n     * @param path\r\n     * @param res\r\n     */\r\n    static setExpires(path: string, res: Response): Promise<any> {\r\n        return new Promise(resolve => {\r\n            if (!Cache.EXPIRES) {\r\n                throw new Error('must set expires!!!');\r\n            }\r\n            File.readFile(path).then(str => {\r\n                const expires = new Date();\r\n                expires.setTime(expires.getTime() + Cache.EXPIRES);\r\n                res.setHeader('Expires', expires.toUTCString());\r\n                resolve(str);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 设置catch-control\r\n     * @param path\r\n     * @param res\r\n     */\r\n    static setCacheControl(path: string, res: Response): Promise<any> {\r\n        return new Promise(resolve => {\r\n            File.readFile(path).then(str => {\r\n                res.setHeader(\"Cache-Control\", \"max-age=\" + Cache.EXPIRES);\r\n                resolve(str);\r\n            });\r\n        })\r\n    }\r\n\r\n    private static getHash (str: string) {\r\n        const shaSum = crypto.createHash('sha1');\r\n        return shaSum.update(str).digest('base64');\r\n    }\r\n}"]}